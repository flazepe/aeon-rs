use crate::{
    statics::{
        REQWEST, REST,
        regex::{DISCORD_URL_REGEX, SPOILER_REGEX},
    },
    structs::{
        database::{Database, redis::keys::RedisKey},
        gateway::events::EventHandler,
    },
};
use anyhow::Result;
use nipper::Document;
use regex::Captures;
use reqwest::StatusCode;
use serde::{Deserialize, Serialize};
use serde_json::json;
use slashook::{
    commands::MessageResponse,
    structs::messages::{AllowedMentions, Message as SlashookMessage, MessageReference},
};
use std::collections::HashMap;
use twilight_model::channel::message::{Message, MessageFlags};

impl EventHandler {
    pub async fn handle_fix_embeds(message: &Message) -> Result<()> {
        let Some(guild_id) = &message.guild_id else { return Ok(()) };

        let mongodb = Database::get_mongodb()?;
        let guild = mongodb.guilds.get(guild_id).await?;

        if !guild.fix_embeds.enabled || message.author.bot {
            return Ok(());
        }

        let mut discord_urls: HashMap<String, DiscordURL> = HashMap::new();

        let mut process_captures = |captures: Captures<'_>, is_spoiler: bool| {
            let suppressed_url = captures.name("suppressed_url");
            let normal_url = captures.name("normal_url");

            let url = suppressed_url.or(normal_url);
            let Some(url) = url else { return };

            if let Some(discord_url) = discord_urls.get_mut(url.as_str()) {
                discord_url.spoilered = is_spoiler;
                discord_url.suppressed = suppressed_url.is_some();
            } else {
                discord_urls.insert(
                    url.as_str().to_string(),
                    DiscordURL { url: url.as_str().to_string(), spoilered: is_spoiler, suppressed: suppressed_url.is_some() },
                );
            }
        };

        for captures in DISCORD_URL_REGEX.captures_iter(&message.content) {
            process_captures(captures, false);
        }

        for spoiler in SPOILER_REGEX.find_iter(&message.content) {
            for captures in DISCORD_URL_REGEX.captures_iter(spoiler.as_str()) {
                process_captures(captures, true);
            }
        }

        // If the message has embeds suppressed, we really have to fix all URLs
        let force_fix_all = message.flags.is_some_and(|flags| flags.contains(MessageFlags::SUPPRESS_EMBEDS));

        let mut fixed_urls = vec![];

        for discord_url in discord_urls.values() {
            // Discord only embeds up to 5 URLs
            if fixed_urls.len() == 5 {
                break;
            }

            if discord_url.suppressed && !force_fix_all {
                continue;
            }

            let url = &discord_url.url;
            let Some(domain) = url.split('/').nth(2).map(|domain| domain.trim_start_matches("www.")) else { continue };

            // Skip X posts that have a valid image
            if ["x.com", "twitter.com"].contains(&domain) && !force_fix_all {
                let html = REQWEST.get(url).header("user-agent", "discordbot").send().await?.text().await?;
                let image_url = get_meta_contents(html, &["og:image"]).into_values().next().unwrap_or_default();

                // Make sure the URL contains the "media" path. Otherwise, it is most likely a thumbnail for a video, which should be fixed
                // Also make sure that it's a valid media (status code OK). Sometimes it likes to return a placeholder URL that leads to a 404
                if !image_url.is_empty()
                    && image_url.contains("/media/")
                    && REQWEST.head(image_url).send().await.is_ok_and(|res| res.status() == StatusCode::OK)
                {
                    continue;
                }
            }

            // Skip TikTok posts that have a valid iframe player embed
            if domain.ends_with("tiktok.com") && !force_fix_all {
                let res = REQWEST.get(url).header("user-agent", "discordbot").send().await?;
                let redirected_url = res.url().to_string();
                let html = res.text().await?;

                if get_meta_contents(html, &["og:url"]).values().next().is_some_and(|url| url.contains("/video/")) {
                    // Only URLs from base tiktok.com and vm.tiktok.com embed properly on Discord
                    // - vm.tiktok.com URLs generated by TikTok Lite (the IDs are longer and include a "-" in them) do not embed at all, despite having the same HTML responses
                    // - vt.tiktok.com URLs embed, but the player does not work (it just shows a thumbnail with the play button, but it's a still image lmao)
                    // We add the base tiktok.com redirects to the fixed URLs before continuing the loop
                    if (domain == "vm.tiktok.com" && url.split('?').next().unwrap_or_default().contains('-')) || domain == "vt.tiktok.com" {
                        fixed_urls.push(redirected_url.split("?").next().unwrap_or_default().to_string());
                    }

                    continue;
                }
            }

            let fixed_domain = match domain {
                "bilibili.com" | "m.bilibili.com" => "vxbilibili.com",
                "instagram.com" => "eeinstagram.com",
                "pixiv.net" => "phixiv.net",
                "reddit.com" | "old.reddit.com" => "rxddit.com",
                "weibo.com" | "m.weibo.com" | "weibo.cn" | "m.weibo.cn" => "fxweibo.com",
                "x.com" | "twitter.com" => "fixupx.com",
                _ => continue,
            };
            let path = url.split("?").next().unwrap_or_default().split('/').skip(3).collect::<Vec<&str>>().join("/");
            let fixed_url = format!("https://{fixed_domain}/{path}");

            if fixed_urls.contains(&fixed_url) {
                continue;
            }

            let has_media_content_type = !force_fix_all
                && REQWEST.head(&fixed_url).header("user-agent", "discordbot").send().await?.headers().get("content-type").is_some_and(
                    |value| value.to_str().unwrap_or_default().contains("image") || value.to_str().unwrap_or_default().contains("video"),
                );

            let has_media_meta_content = !has_media_content_type && {
                let html = REQWEST.get(&fixed_url).header("user-agent", "discordbot").send().await?.text().await?;
                !get_meta_contents(html, &["og:image", "og:video", "twitter:card", "twitter:image", "twitter:video"]).is_empty()
            };

            // Only fix posts that were supposed to have an image or video
            if force_fix_all || has_media_content_type || has_media_meta_content {
                // The space before the closing spoiler is intentional because Discord (could be the website) sometimes includes the || inside the URL when unfurling, which causes the website to return a 404 and not embed
                fixed_urls.push(if discord_url.spoilered { format!("||{fixed_url} ||") } else { fixed_url });
            }
        }

        let response = MessageResponse::from(format!(
            "<@{}> {}",
            message.author.id,
            if fixed_urls.is_empty() { "_Message was edited to not contain any fixable URLs._".into() } else { fixed_urls.join("\n") },
        ))
        .set_message_reference(MessageReference::new_reply(message.id))
        .set_allowed_mentions(AllowedMentions::new());

        let redis = Database::get_redis()?;
        let Some(guild_id) = message.guild_id else { return Ok(()) };
        let channel_id = message.channel_id;
        let message_id = message.id;
        let embed_fix_response_key =
            RedisKey::GuildChannelMessageEmbedFixResponse(guild_id.to_string(), channel_id.to_string(), message_id.to_string());

        if let Ok(mut embed_fix_response) = redis.get::<EmbedFixResponse>(&embed_fix_response_key).await {
            let embed_fix_response_id = &embed_fix_response.id;

            if embed_fix_response.discord_urls.iter().ne(discord_urls.iter()) {
                _ = REST
                    .patch::<(), _>(
                        format!("channels/{channel_id}/messages/{embed_fix_response_id}"),
                        json!({ "content": response.content.unwrap_or_default(), "allowed_mentions": { "parse": [] } }),
                    )
                    .await;

                embed_fix_response.discord_urls = discord_urls;
                redis.set(&embed_fix_response_key, embed_fix_response, Some(60 * 5)).await?;
            }

            return Ok(());
        }

        if !fixed_urls.is_empty()
            && let Ok(embed_fix_response_message) = SlashookMessage::create(&REST, channel_id, response).await
        {
            _ = REST
                .patch::<(), _>(format!("channels/{channel_id}/messages/{message_id}"), json!({ "flags": MessageFlags::SUPPRESS_EMBEDS }))
                .await;

            redis
                .set(
                    &embed_fix_response_key,
                    EmbedFixResponse { id: embed_fix_response_message.id.unwrap_or_default(), discord_urls },
                    Some(60 * 5),
                )
                .await?;
        }

        Ok(())
    }
}

fn get_meta_contents(html: String, names: &[&str]) -> HashMap<String, String> {
    let document = Document::from(&html);
    let mut contents = HashMap::new();

    for name in names {
        let name_content = document.select(&format!("meta[name='{name}']")).attr("content");
        let property_content = document.select(&format!("meta[property='{name}']")).attr("content");
        let Some(content) = name_content.or(property_content) else { continue };

        // Ignore some invalid contents
        if ["0", "undefined"].contains(&content.to_string().as_str()) || content.starts_with("https://pbs.twimg.com/profile_images/") {
            continue;
        }

        contents.insert(name.to_string(), content.to_string());
    }

    contents
}

#[derive(Serialize, Deserialize, PartialEq)]
pub struct DiscordURL {
    pub url: String,
    pub spoilered: bool,
    pub suppressed: bool,
}

#[derive(Serialize, Deserialize)]
pub struct EmbedFixResponse {
    pub id: String,
    pub discord_urls: HashMap<String, DiscordURL>,
}
